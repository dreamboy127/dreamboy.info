---
layout: post
title:  解救小Q
categories: [acm]
tags: [acm,DFS]
description: 深度优先搜索，迷宫问题，陷阱，传送门
---
###Description 
小Q被邪恶的大魔王困在了迷宫里，要去解救她。
迷宫里面有一些陷阱，一旦走到陷阱里，就会被困身亡，迷宫里还有一些古老的传送阵，一旦走到传送阵上，会强制被传送到传送阵的另一头。
现在请你算一算，至少需要走多少步才能解救到小Q？ 
{{ site.excerpt_separator }}
###Input 
第一行为一个整数T，表示测试数据组数。
每组测试数据第一行为两个整数N，M，(1 <= N, M <= 50)表示
迷宫的长和宽。
接下来有N行，每行M个字符，是迷宫的具体描述。
'.'表示安全的位置，'#'表示陷阱，
'Q'表示小Q的位置，'L'表示你所在位置，
数据保证L只有一个，数据也保证小Q只有一个。
小写字母'a'-'z'表示分别表示不同的传送阵，数据保证传送阵
两两配对。 
###Output 
每组数据输出一行，解救小Q所需的最少步数，如果无论如何都无法救小Q，输出-1。
###Simple Input 
```
2
5 5
....L
.###.
b#b#a
##.##
...Qa
```
```
5 5
....L
.###.
.#.#.
##.##
...Q. 
```

###Simple Output 
```
3
-1
```
##C语言代码如下
```c
#include <stdio.h>
#include <stdlib.h>
#include <malloc.h>
typedef struct point
{
	char x;
	char y;
	struct point *parent;
}Point;

typedef struct QueueNode{
    Point data;     
    struct QueueNode *next;     
}QueueNode;
typedef struct queueLK{
    QueueNode *front;    
    QueueNode *rear;       
}QueueLK;

Point L_point;
Point Q_point;
Point az_point[26][2];
QueueLK *Queue;
char **map;

int Steps_rescueQ(char m,char n,char **map);
void LookAround(Point *Current,char direction,char m,char n,char **map);

void InitQueue(QueueLK *Queue);
void InQueue(QueueLK *Queue, Point x);
void OutQueue(QueueLK *Queue,Point **x);
int IsEmptyQueue(QueueLK *Queue);

int main(void)
{
	int i,maps,j,k,m,n,*Steps;
	Queue=(QueueLK*)malloc(sizeof(QueueLK));
	scanf("%d",&maps);
	Steps=(int*)malloc(sizeof(int)*maps);
	
	for(i=0;i<maps;i++)
	{
		memset(az_point,-1,sizeof(az_point));
		scanf("%d %d",&m,&n);
		getchar();
		map=(char**)malloc(sizeof(char*)*m);
		for(j=0;j<m;j++)
			map[j]=(char*)malloc(sizeof(char)*n);
		for(j=0;j<m;j++)
		{
			for(k=0;k<n;k++)
			{
				scanf("%c",&map[j][k]);
				
				if(map[j][k]=='L')
				{
				L_point.x=j;
				L_point.y=k;
				L_point.parent=NULL;
				}
				else if(map[j][k]=='Q')
				{
				Q_point.x=j;
				Q_point.y=k;
				Q_point.parent=NULL;
				}
				else if(map[j][k]>='a'&&map[j][k]<='z')
				{
					if(az_point[map[j][k]-'a'][0].x==-1&&
					az_point[map[j][k]-'a'][0].y==-1)
					{
						az_point[map[j][k]-'a'][0].x=j;
						az_point[map[j][k]-'a'][0].y=k;
					}
					else
					{
						az_point[map[j][k]-'a'][1].x=j;
						az_point[map[j][k]-'a'][1].y=k;
					}
				}
			}
			getchar();
		}
		Steps[i]=Steps_rescueQ(m,n,map);
		for(j=0;j<m;j++)
		{
			free(map[j]);
		}
		free(map);
		printf("\n");
	}
	
	for(i=0;i<maps;i++)
	{
		printf("%d\n",Steps[i]);
	}
	return 0;
}
int Steps_rescueQ(char m,char n,char **map)
{
	char i,j,direction;
	char step=0;
	
	Point *Current;
	InitQueue(Queue);
	InQueue(Queue,L_point);
	map[L_point.x][L_point.y]='#';
 	while(!IsEmptyQueue(Queue))
	{
		OutQueue(Queue,&Current);
		if(Current->x==Q_point.x&&Current->y==Q_point.y)
		{
				while(1)
				{
					step++;
					Current=Current->parent;
					if(Current->x==L_point.x&&Current->y==L_point.y)
						return step;
				}
		}
		for(direction=0;direction<4;direction++)
		{
			LookAround(Current,direction,m,n,map);
		}
	}
	return -1;
}
void LookAround(Point *Current,char direction,char m,char n,char **map)
{
	Point next;
	switch(direction)
	{
	case 0:
				if(Current->y==n-1)return;
				next.x=Current->x;
				next.y=Current->y+1;break;
	case 1:
				if(Current->x==m-1)return;
				next.y=Current->y;
				next.x=Current->x+1;break;
	case 2:
				if(Current->y==0)return;
				next.x=Current->x;
				next.y=Current->y-1;break;
	case 3:
				if(Current->x==0)return;
				next.y=Current->y;
				next.x=Current->x-1;break;
	default:return;
	}
	if(map[next.x][next.y]=='.')
	{
		next.parent=Current;
		InQueue(Queue,next);
		map[next.x][next.y]='#';
	}
	else if(map[next.x][next.y]=='Q')
	{
		next.parent=Current;
		InQueue(Queue,next);
		map[next.x][next.y]='#';
	}
	else if(map[next.x][next.y]>='a'&&map[next.x][next.y]<='z')
	{
		int temp=map[next.x][next.y]-'a';
		if(az_point[temp][0].x==next.x&&
		   az_point[temp][0].y==next.y)
		{
			next.x=az_point[temp][1].x;
			next.y=az_point[temp][1].y;
			if(next.x!=Current->x||next.y!=Current->y)
			{
			next.parent=Current;
			InQueue(Queue,next);
			}
		}
		else
		{
			next.x=az_point[temp][0].x;
			next.y=az_point[temp][0].y;
			if(next.x!=Current->x||next.y!=Current->y)
			{
			next.parent=Current;
			InQueue(Queue,next);
			}
		}
	}
	
}
void InitQueue(QueueLK *Q)
{
    Q->front=(QueueNode*)malloc(sizeof(QueueNode));
	Q->rear=Q->front;
	if(!Q->front)
		exit(1);
	Q->front->next=NULL; 
    return;
}
void InQueue(QueueLK *Q, Point data)
{
    QueueNode *newP;
    newP = (QueueNode *)malloc(sizeof(QueueNode));
    if(newP == NULL){
        printf("内存空间分配失败！ ");
        exit(1);
    }

    newP->data.parent = data.parent;
	newP->data.x = data.x;
	newP->data.y = data.y;
    newP->next = NULL;

        Q->rear->next = newP;   
		Q->rear = newP;
    return;
}
void OutQueue(QueueLK *Q,Point **data)
{
    QueueNode *p;
    if(Q->front == Q->rear){
        printf("队列为空，无法删除！ ");
        exit(1);
    }
	p = Q->front->next;             
	*data=&(p->data);
    Q->front->next = p->next;        
    if(Q->rear == p){
        Q->rear = Q->front;
    }
    //free(p); 
}
int IsEmptyQueue(QueueLK *Q)
{
    if(Q->front==Q->rear){
        return 1;
    }else{
        return 0;
    }
}
```